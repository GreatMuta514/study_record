# 演算子

## 指数表現

10の1.5乗とは？

よくわからん

### 文字列混在の計算式

phpでは文字列が混在している場合でも、認識できる数値だけを汲み取って計算する。

```php
print '108' + '1.5XYZ'; //109.5
print '108' + 'XYZ10'; // エラー
print '108' + '1.5XYZ10'; // 109.5
```

### 前置演算と後置演算( ++ -- )

前置演算

```php
$x = 10;
$y = ++$x; // 前置演算（++を前に置く）
print $x; // 10
print $y; // 11
```

後置演算

```php
$i = 10;
$j = $i++; // 後置演算（++を後ろに置く）
print $i; // 11
print $j; // 10
```

++(--)を前に置くと演算してから代入される。後ろに置くと代入してから演算が行われる。

### マジカルインクリメント

文字列が混在していても、++ (--)は実行できる。（次のアルファベットに行く）

### 浮動小数点の計算

浮動小数展の計算はコンピューターが二進数で実施するので問題が生じる時がある。よってbcaddなどの関数を使う。

### 配列の演算

phpにおける配列の加算では、「もともと存在しないキーが該当するプロパティだけを後ろのインデックスに追加する」。（もともとあるキーのバリューは更新しない。）

```php
$assoc1 = [
  'Apple' => 'Red',
  'Orange' => 'Yellow',
  'Melon' => 'Green'
];
$assoc2 = [
  'Grape' => 'Purple',
  'Apple' => 'Green',
  'Strawberry' => 'Red'
];
$result = $assoc1 + $assoc2;
print_r($result);

/*
Array
(
    [Apple] => Red
    [Orange] => Yellow
    [Melon] => Green
    [Grape] => Purple
    [Strawberry] => Red
)
*/
```

```php
$ary1 = [1, 3, 5];
$ary2 = [2, 3, 6];
$result = $ary1 + $ary2;
print_r($result);

/*
Array
(
    [0] => 1
    [1] => 3
    [2] => 5
)
*/
```

## 変数

- メモリには番号が割り振られているが、番号をコードに書くとわかりにくい。→人間が分かりやすいように名前をつける。

### 「値代入」と「参照代入」の違い

**値代入**

- 挙動：あるアドレスの値を、別のアドレスにコピー

```php
<?php
$x = 1;
$y = $x;
$x = 5;
print $y; // 1
```

値をコピーして別アドレスに貼り付けているので、元のアドレスの値は変わらない。

**参照代入**

- 記憶領域（アドレスと値のセットを丸ごと）を引き渡す。

```php
<?php
$x = 1;
$y = &$x; // 参照代入は&で表現
$x = 5;
print $y; // 5（$yと$xは同じアドレスなので）
```

言い換えると、変数の名前を変更しているだけ。

### 分割代入

配列の要素のバリューを変数にできる

```php
**<?php
$data = [1, 2, 3, 4, 5];
[$a, $b, $c, $d, $e] = $data;

print $a; // 1
print $b; // 2**
```

**特定の値だけを変数にする場合**

不足分がある場合は、$_でスキップ。

```php
<?php
$data = [1, 2, 3, 4, 5];
[$_, $a, $_, $b, $c] = $data;
print $a;
print '<br />';
print $b;
print '<br />';
print $c;
```

**変数のスワッピング**

変数の値を入れ替えることもできる。入れ替えることをスワッピングという。

```php
<?php
$x = 15;
$y = 38;
[$y, $x] = [$x, $y];
print $x;
print $y;
```

## 比較演算子

### ==と===の違い

```php
1 == '1' // true
1 === '1' // false
```

**==**

- 「等しいとみなせそうなもの」はtrueになる
- バージョンによって挙動が異なる

**===**

- 厳格に判定してくれる

### 浮動小数店同士の比較は要注意

詳しくはp104

### ショートカット演算子

&&や||で左式で結果が決まる場合、右式は実行されない。

### 文字列演算式

`.`

文字列と文字列の連結

### 実行演算子

バッククォートで囲ってシェルコマンドを実行。

```php
<?php
$result = `ls -la`;
print mb_convert_encoding($result, 'UTF-8', 'SJIS');
```

画面にカレントディレクトリ配下にあるファイルが表示される

### エラー制御演算子

@をつけることでエラーが発生しても出力しない

```php
<?php
$data = [ 'apple' => 'りんご' ];
print $data['orange']; // Warning ...
print @$data['orange']; // 何も表示されず
```

### 演算子の優先順位

p119を参照。

### 結合則

同じ優先順位の演算子が複数存在する場合に、その中で実行順序を決める役割が結合則。

**左結合**

+、-は左結合（左から実行される）

```php
// 以下二つは同じ結果
5 + 7 -1
(5 + 7) - 1
```

**右結合**

=、+=は右結合。（右から実行される）

```php
// 以下の実行結果は同じ、右の+=から実行される

$b = $a += 1
$b = ($a += 1)
```

**非結合（一つの式に2個置けない）**

```php
$a == $b == $c // エラー(unexpected '==')
```

上は以下なら許される。（一つまでなのでOK）

```php
$a == $b
$b == $c
```

# プログラマにとってCPUとは何か

# CPUとは

以下の4つから構成される。

- レジスタ
- 制御装置
- 演算装置
- クロック

## レジスタ

- プログラムに記述された命令・データを格納する領域。
- 命令・データはメモリ（CPU外部に存在する）から読み込む。
- 一つのCPUに数個〜数十個存在する。

## 制御装置

- メモリからCPU内のレジスタに命令やデータを取り出す。
- 命令に応じてコンピューター全体を制御する

## 演算装置

- メモリから取り出したデータを演算する役割を担う

## クロック

- クロック信号を発生させるもの。（クロック信号とは：https://wa3.i-3-i.info/word1978.html）
- クロック周波数は高ければ高いほど処理が速い

### 結論：CPUはレジスタの集合体

プログラマ視点ではCPUのレジスタにのみ注目すれば良いので、CPU==レジスタの集合体と捉えて良い。

# アセンブリ言語

機械語を人間にもわかる言葉に置き換えた言語。機械語と一対一に対応している。（プログラミング言語は一対一に対応していないので、この点が大きく異なる。）

## アセンブル

「アセンブリ言語で書かれたプログラム」を機械語に置き換えることをアセンブルという。

## 逆アセンブル

機械語をアセンブリ言語に置き換えること。

## コンパイル

プログラミング言語を機械語に置き換えること。

## レジスタの種類

### プログラム・カウンタ

- プログラム・カウンタはアドレス番号が格納されるレジスタ。プログラム・カウンタに書かれているアドレスの命令が実行される。
- アドレスを実行すると1増える。（場合によっては1とは限らない）

**順次実行・条件分岐・繰り返しの仕組みはプログラム・カウンタにある**

- 順次実行の場合1増加
- 条件分岐、繰り返しの場合は任意の値変化する

### フラグ・レジスタ

- 直前に実行した演算の結果を保存する役割を担うレジスタ。
- フラグ・レジスタに保存されたデータはジャンプ処理（例えばif文など）で参照される
- フラグ・レジスタのデータは以下で該当するものが1になる
    - 0ビット目：正
    - 1ビット目：0
    - 2ビット目：負 

